============== EXPLICACION ==============
Existe un area compartida entre procesos
    donde hay procesos que solo leen y
    hay otros que solo escriben
Escritor --> Area --> Lectores
Cualquier numero de lectores puede leer el area de datos simultaneamente
Si un escritor esta accediendo al archivo, ningun lector puede leer
Solo escritor puede escribir al mismo tiempo
============== SEMAFOROS ==============
// prioridad lectores
// un escritor solo puede escribir si no hay escritores leyendo
int contlect = 0;
semaphore x, essem;

Lesctor(){
    while(forever){
        wait(x);
        contlect++;
        if(contlect == 1) wait(essem); // no permitir que los escritores escribar
        signal(x);
        LEER_UNIDAD;
        wait(x);
        contlect--;
        if(contlect == 0) signal(essem); // si no hay mas escritores avisa a los escritores
        signal(x);
    }
}

Escritor(){
    while(forever){
        wait(essem);
        ESCRIBIR_UNIDAD;
        signal(essem);
    }
}

main(){
    contlect = 0;
    initsem(x,1); // protege seccion critica para incrementar, decrementar y comparar <contlect>
    initsem(essem,1); // si un escritor puede o no escribir
    cobeging{
        Lector(); ... Lector();
        Escritor(); ... Escritor();
    }
}

----------------------------
// prioridad escritores
// un escritor solicita escbir por lo que ningun lector puede leer
int contlect = 0, contesc = 0;
semaphore x, y, z, essem, lsem;

Lesctor(){
    while(forever){
        wait(z); // con este se evita que un escritor se quede por detras de una cantidad de lectores
            wait(lsem); // aca solo se debe bloquear un lector, por eso wait(z)
                wait(x);
                    contlect++;
                    if(contlect == 1) wait(essem); // no permitir que los escritores escribar
                signal(x);
            signal(lsem);
        signal(z);
        LEER_UNIDAD;
        wait(x);
            contlect--;
            if(contlect == 0) signal(essem); // si hay un escritor esperando pueda escribir
        signal(x);
    }
}

Escritor(){
    while(forever){
        wait(y);
            contesc++;
            if(contesc == 1) wait(lsem); // si hay un lector no pueda leer
        signal(y);
        wait(essem);
            ESCRIBIR_UNIDAD;
        signal(essem);
        wait(y);
            contesc--;
            if(contesc == 0) signal(lsem); // si hay mas escritores avisa a los lectores que pueden escribir
        signal(y);
    }
}

main(){
    contlect = 0;
    initsem(x,1); // para poder incrementar, decrementar y comparar <contlect>
    initsem(y,1); // para poder incrementar, decrementar y comparar <contesc>
    initsem(z,1); // controlar prioridad a los escritores
    initsem(essem,1); // si un escritor puede o no escribir
    initsem(lsem,1);
    cobeging{
        Lector(); ... Lector();
        Escritor(); ... Escritor();
    }
}
============== MENSAJES ==============
// prioridad escritores
// hay buzones de solicitud de lectura y de escritura y de terminado
// cada lector y consumidor tiene su buzon y hay un Controlador
int contlect = 0;
semaphore x, essem;

Lesctor_i(){
    mensaje msjl;
    while(forever){
        msjl = i;
        send(solicitud_lectura, msjl); //no bloqueante
        receive(buzon_i, msjl); //bloqueante (una vez que el controlador lo habilita puede leer)
        LEER_UNIDAD;
        msjl = i;
        send(terminado, msjl);
    }
}

Escritor_j(){
    mensaje msjl;
    while(forever){
        msjl = j;
        send(solicitud_escritura, msjl); // no bloqueante
        receive(buzon_j, msjl); // bloqueante (espera la autorizacion del controlador)
        ESCRIBIR_UNIDAD;
        msjl = j;
        send(terminado, msjl);
    }
}

Controlador(){
    mensaje msj;
    int cont = 100;
    while (forever){
        if(cont > 0){
            if(!vacio(terminado)) { // YA HAY QUIENES TERMINARON
                receive(terminado, msj);
                cont++;
            } else if (!vacio(solicitud_escritura)){ // HAY QUIEN
                receive(solicitud_escritura, msj); // QUIERE ESCRIBIR
                escritor.id := msj.id; // ESCRIBIR
                cont = cont - 100;
            } else if(!vacio(solicitud_lectura)){ // HAY QUIEN QUIERE
                receive(solicitud_lectura, msj); // LEER
                cont--;
                send(msj.id, "OK");
            }
        }
        if (cont == 0){
            send(escribir.id, "OK"); //CONCEDER ESCRITURA
            receive(terminado, msj); // ESPERO A QUE TERMINE
            cont = 100; // DE ESCRIBIR
        }
        while(cont < 0){ // SI HAY LECTORES PENDIENTES DE TERMINAR
            receive(terminado, msj); // LOS ESPERA
            cont++;
        }
    }
}

main(){
    contlect = 0;
    initsem(x,1); // protege seccion critica para incrementar, decrementar y comparar <contlect>
    initsem(essem,1); // si un escritor puede o no escribir
    cobeging{
        Lector(); ... Lector();
        Escritor(); ... Escritor();
    }
}